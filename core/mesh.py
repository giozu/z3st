# --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. ---
# Z3ST: An open-source FEniCSx framework for thermo-mechanical analysis
# Author: Giovanni Zullo
# Version: 0.1.0 (2025)
# --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. ---

from mpi4py import MPI
import dolfinx
import ufl
import pyvista
import matplotlib.cm as cm
import numpy as np
import importlib.util
import pathlib

class Mesh:
    def __init__(self, mesh_file, geometry, rank=0, gdim=3):

        """
        Initialize the class with the mesh file.

        Parameters:
        mesh_file (str): Path to the mesh file.
        rank (int): Rank of the process (default is 0).
        gdim (int): Geometric dimension of the mesh (default is 3).
        """
        print("__Mesh initializer__")

        self.mesh_file = mesh_file
        self.rank = rank
        self.gdim = gdim
        self.geometry = geometry
        
        self._read_mesh()

    def _read_mesh(self):
        """
        Read the mesh and facet tags from the specified mesh file.
        """
        print(f"Reading mesh file {self.mesh_file}")

        try:
            path = pathlib.Path(self.mesh_file)
            print(f"Mesh file exists? {path.exists()}. Located at {self.mesh_file}") 
            print(f"Mesh file extension: {path.suffix}")
            # if path.suffix == ".py":
            #     # the mesh is generated by a python script, specified in input.yaml (mesh_path: mesh.py)
            #     spec = importlib.util.spec_from_file_location("mesh_builder", self.mesh_file)
            #     mesh_builder = importlib.util.module_from_spec(spec)
            #     spec.loader.exec_module(mesh_builder)
            #     builder = mesh_builder.MeshBuilder(self.geometry_path)
            #     self.mesh, self.volume_tags, self.ft = builder.build()
            # else:
            # the mesh is a standard mesh file (.msh, ...)
            mesh_data = dolfinx.io.gmsh.read_from_msh(self.mesh_file, MPI.COMM_WORLD, rank=self.rank, gdim=self.gdim)
            self.mesh, self.volume_tags, self.ft =  mesh_data.mesh, mesh_data.cell_tags, mesh_data.facet_tags   

        except Exception as e:
            raise ValueError(f"Error reading mesh file {self.mesh_file}: {e}")

        self.tdim = self.mesh.topology.dim
        print(f"Info    : Mesh topology dimension d={self.tdim}")

        self.fdim = self.tdim - 1
        self.mesh.topology.create_connectivity(self.fdim, self.tdim)
        self.mesh.topology.create_connectivity(self.tdim, self.tdim) 
        self.boundary_facets = dolfinx.mesh.exterior_facet_indices(self.mesh.topology)
        
        print("\nAvailable volume tags (dx):")
        tag_values = self.volume_tags.values
        unique_tags = set(tag_values)
        for tag in sorted(unique_tags):
            print(f"  Tag ID: {tag}")

        # Labels
        self.label_map = self.geometry["labels"]

        print("\n--- Verifying facet tags ---")
        unique_tags = np.unique(self.ft.values)
        print(f"Unique tags found in mesh facet data (self.ft): {unique_tags}")

        print("Geometry entries:")
        for k in sorted(self.geometry.keys()):
            if k == "labels":
                continue
            v = self.geometry[k]
            print(f"  {k:<15} → {v} ({type(v).__name__})")

        print(f"  name = {self.geometry["name"]}")

        self.geometry_type = self.geometry.get("geometry_type", "").lower()
        print(f"  geometry_type = {self.geometry_type}")

        self.Lz = float(self.geometry.get("Lz", 0.0))
        print(f"  Lz = {self.Lz:.3f} m")

        if self.geometry_type == "rect":
            self.Lx = float(self.geometry.get("Lx", None))
            self.Ly = float(self.geometry.get("Ly", None))
            self.perimeter = (self.Lx + self.Ly) * 2.0
            self.area = self.Lx * self.Ly
            print(f"  Lx = {self.Lx:.3f} m")
            print(f"  Ly = {self.Ly:.3f} m")

        elif self.geometry_type == "cyl" or self.geometry_type == "cylinder":
            self.inner_radius = self.geometry.get("Ri", 0.0)
            self.outer_radius = self.geometry.get("Ro", None)
            self.perimeter = 2.0 * np.pi * self.outer_radius
            self.area = np.pi * (self.outer_radius**2 - self.inner_radius**2)
            print(f"  inner_radius = {self.inner_radius:.2e} m")
            print(f"  outer_radius = {self.outer_radius:.2e} m")

        elif self.geometry_type == "cyl-cyl":
            self.inner_radius_1 = self.geometry.get("inner_radius_1", None)
            self.outer_radius_1 = self.geometry.get("outer_radius_1", None)
            self.inner_radius_2 = self.geometry.get("inner_radius_2", None)
            self.outer_radius_2 = self.geometry.get("outer_radius_2", None)
            self.perimeter = 2. * np.pi * self.outer_radius_1
            self.area = np.pi * (self.outer_radius_1**2 - self.inner_radius_1**2)
            print(f"  inner_radius_1 = {self.inner_radius_1:.2e} m")
            print(f"  outer_radius_1 = {self.outer_radius_1:.2e} m")
            print(f"  inner_radius_2 = {self.inner_radius_2:.2e} m")
            print(f"  outer_radius_2 = {self.outer_radius_2:.2e} m")

        elif self.geometry_type == "sphere":
            self.inner_radius = self.geometry.get("Ri", None)
            self.outer_radius = self.geometry.get("Ro", None)
            self.perimeter = 2. * np.pi * self.outer_radius
            self.area = np.pi * (self.outer_radius**2 - self.inner_radius**2)
            print(f"  inner_radius = {self.inner_radius:.2e} m")
            print(f"  outer_radius = {self.outer_radius:.2e} m")

        print(f"  area = {self.area:.3e} m2")
        print(f"Label map from '{self.input_file["geometry_path"]}'")
        for label, tag in sorted(self.label_map.items(), key=lambda item: item[1]):
            print(f"  {label:<12} → {tag}")
        
        self.normal = ufl.FacetNormal(self.mesh)

    def locateFacetDofs(self, label: int, V: dolfinx.fem.functionspace) -> np.ndarray:
        """Locate degrees of freedom (DoFs) on a specific facet boundary.

        This is a convenience function for finding all DoFs associated with
        a boundary marked by a specific integer label. It's commonly used
        to apply boundary conditions (e.g., DirichletBC).

        Args:
            label: The integer marker for the desired facet set (e.g., a
                   specific boundary like an "inlet" or "wall"). This label must
                   exist in the mesh's facet tags.
            V: The function space from which to extract the DoFs.

        Returns:
            A 1D numpy array of DoF indices that are located on the
            specified facets.
        """
        # Find the indices of all facets (e.g., edges in 2D, faces in 3D)
        # that are marked with the given integer 'label'.
        # self.ft is the MeshTags object for facets.
        facets = self.ft.find(label)

        # Locate the DoFs that are topologically associated with these facets.
        # - V: The function space defines the DoFs.
        # - self.fdim: The topological dimension of the entities to search on (dim-1).
        # - facets: The list of entity indices to search.
        return dolfinx.fem.locate_dofs_topological(V, self.fdim, facets)

    def locateDomainDofs(self, label_map: dict, material_label: str, V: dolfinx.fem.functionspace) -> np.ndarray:
        """Locate degrees of freedom (DoFs) within a specific subdomain.

        This function identifies all DoFs that belong to cells of a certain
        type (e.g., a specific material). It is useful for defining
        material-dependent properties, source terms, or for subdomain-specific
        post-processing.

        Args:
            label_map: A dictionary mapping human-readable material labels
                       (e.g., "water", "steel") to their corresponding integer
                       tags in the mesh's cell data.
            material_label: The human-readable key (e.g., "water") to look
                            up the integer tag in `label_map`.
            V: The function space from which to extract the DoFs.

        Returns:
            A 1D numpy array of DoF indices located within the cells of the
            specified subdomain.
        """
        # Use the map to get the integer tag corresponding to the material label.
        # This decouples the physics definition from the mesh generation details.
        domain_tag = label_map[material_label]

        # Find the indices of all cells (e.g., triangles in 2D, tetrahedra in 3D)
        # that are marked with that integer domain tag.
        # self.volume_tags is the MeshTags object for cells.
        cells = self.volume_tags.find(domain_tag)

        # Locate the DoFs that are topologically associated with these cells.
        # - V: The function space defines the DoFs.
        # - self.tdim: The topological dimension of the entities (the cells themselves).
        # - cells: The list of cell indices to search.
        dofs = dolfinx.fem.locate_dofs_topological(V, self.tdim, cells)
        return dofs

    def volume(self, log_path="output/simulation_log.txt"):

        # Integration measures the domain
        for label in ["cyl_1", "cyl_2"]:
            if label in self.label_map:
                tag = self.label_map[label]
                setattr(self, f"dx_{label}", self.dx(tag))
                print(f"[INFO] Defined dx_{label} for tag ID {tag}")

        # Compute mesh volumes
        volume = dolfinx.fem.assemble_scalar(dolfinx.fem.form(1 * self.dx))
        volume_1 = dolfinx.fem.assemble_scalar(dolfinx.fem.form(1 * self.dx_1))
        volume_2 = dolfinx.fem.assemble_scalar(dolfinx.fem.form(1 * self.dx_2))
        
        with open(log_path, "a") as f:
            f.write("Mesh Volumes\n")
            f.write("──────────────────────────────────────────────\n")
            f.write(f"{'Volume  (from mesh)':<32}: {volume  *1e9:.3e} mm³\n")
            f.write(f"{'Volume1 (from mesh)':<32}: {volume_1*1e9:.3e} mm³\n")
            f.write(f"{'Volume2 (from mesh)':<32}: {volume_2*1e9:.3e} mm³\n")

    def _mesh_plot(self, mesh_plot_mode):
        # from dolfinx.io import XDMFFile
        
        # self.mesh.topology.create_connectivity(self.fdim , self.tdim)
        # with XDMFFile(self.mesh.comm, "facet_tags.xdmf", "w") as xdmf:
        #     xdmf.write_mesh(self.mesh)
        #     xdmf.write_meshtags(self.volume_tags, self.geometry)

        if mesh_plot_mode is False:
            return
        else:
            topology, cell_types, _ = dolfinx.plot.vtk_mesh(self.mesh, self.mesh.topology.dim - 1)
            surface = pyvista.UnstructuredGrid(topology, cell_types, self.mesh.geometry.x)

            unique_tags = np.unique(self.ft.values)
            print("[INFO] Face labels present:", unique_tags)

            colors = cm.get_cmap("tab10", len(unique_tags))
            label_map = {}
            for i, tag in enumerate(unique_tags):
                label_name = list(self.label_map.keys())[list(self.label_map.values()).index(tag)]
                label_map[tag] = (label_name, colors(i)[:3])

            plotter = pyvista.Plotter()
            for tag, (name, color) in label_map.items():
                facets = self.ft.find(tag)
                cells = surface.extract_cells(facets)
                plotter.add_mesh(cells, color=color, show_edges=True, label=name)

            plotter.add_legend()
            plotter.show()
