#!/usr/bin/env python3
# --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. ---
# Z3ST: An open-source FEniCSx framework for thermo-mechanical analysis
# Author: Giovanni Zullo
# Version: 0.1.0 (2025)
# --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. --- --.. ..- .-.. .-.. ---

# --.. ..- .-.. .-.. --- Z3ST utility module --.. ..- .-.. .-.. ---
"""
Z3ST utility: utils_extract_vtu.py
----------------------------------

Provides functions for extracting physical fields from VTU files
generated by Z3ST simulations. Supports temperature, stress, and
displacement extraction, as well as automatic detection of field
names and coordinate handling.

Typical usage:
--------------
    from utils_extract_vtu import extract_temperature, extract_stress, extract_displacement, list_fields

    x, y, z, T = extract_temperature("output/fields.vtu")
    x, y, z, sigma_xx = extract_stress("output/fields.vtu", component="xx")
    x, y, z, U = extract_displacement("output/fields.vtu")

Author: Giovanni Zullo
Project: Z3ST
Date: 11/10/2025
"""

# --.. ..- .-.. .-.. --- imports --.. ..- .-.. .-.. ---
import os

import numpy as np
import pandas as pd
import pyvista as pv


# --.. ..- .-.. .-.. --- helpers --.. ..- .-.. .-.. ---
def _detect_field(grid, field_name):
    """Find field in VTU file, searching in point and cell data."""
    fname = field_name
    if fname in grid.point_data:
        print(f"[INFO] Found field in point_data: '{field_name}'")
        return "point", field_name
    elif fname in grid.cell_data:
        print(f"[INFO] Found field in cell_data: '{field_name}'")
        return "cell", field_name
    raise KeyError(f"<{field_name}> field not found in VTU file.")


def _detect_temp_field(grid):
    """Find temperature field name in VTU file"""
    for name in ("Temperature", "temperature", "T", "temp"):
        if name in grid.point_data:
            print(f"[INFO] Found temperature field in point_data: '{name}'")
            return "point", name
        elif name in grid.cell_data:
            print(f"[INFO] Found temperature field in cell_data: '{name}'")
            return "cell", name
    raise KeyError("Temperature field not found in VTU file.")


def _detect_displacement(grid):
    """Find displacement field name in VTU file"""
    for name in ("Displacement", "displacement", "U", "u"):
        if name in grid.point_data:
            print(f"[INFO] Found displacement field in point_data: '{name}'")
            return "point", name
        elif name in grid.cell_data:
            print(f"[INFO] Found displacement field in cell_data: '{name}'")
            return "cell", name
    raise KeyError("Displacement field not found in VTU file.")


def _detect_VonMises(grid, prefer="cells"):
    """Find Von Mises equivalent stress in VTU file"""

    if prefer == "cells":
        for name in grid.cell_data.keys():
            if "VonMises_" in name:
                print(f"[INFO] Found VonMises in cell_data: '{name}'")
                return "cell", name

    elif prefer == "points":
        for name in grid.point_data.keys():
            if "VonMises_" in name:
                print(f"[INFO] Found VonMises in point_data: '{name}'")
                return "point", name

    raise KeyError("VonMises field not found in VTU file.")


def _detect_sigma(grid, prefer="points"):
    """
    Detect the stress field in the VTU file.
    Prefer 'Stress_steel (points)' if available, otherwise fallback to cell data.
    """
    if prefer == "points":
        for name in grid.point_data.keys():
            if "stress" in name.lower():
                print(f"[INFO] Found stress field in point_data: '{name}'")
                return "point", name

    elif prefer == "cells":
        for name in grid.cell_data.keys():
            if "stress" in name.lower():
                print(f"[INFO] Found stress field in cell_data: '{name}'")
                return "cell", name

    else:
        raise ValueError(f"Invalid prefer value '{prefer}'. Choose 'points' or 'cells'.")

    print("\n[ERROR] No stress field found in VTU file.")
    print("Available point_data:", list(grid.point_data.keys()))
    print("Available cell_data:", list(grid.cell_data.keys()))
    raise KeyError("No stress field found containing 'Stress_steel'.")


def _data_coords(grid, location, field_name):
    """Retrieve data array and coordinates based on location (point or cell)"""
    if location == "point":
        data = grid.point_data[field_name]
        coords = grid.points
    elif location == "cell":
        data = grid.cell_data[field_name]
        coords = grid.cell_centers().points
    else:
        raise ValueError(f"Invalid location '{location}'. Must be 'point' or 'cell'.")
    return data, coords


# --.. ..- .-.. .-.. --- field listing --.. ..- .-.. .-.. ---
def list_fields(vtu_path):
    """
    List all point_data and cell_data fields in a VTU file.
    Check also the mesh grid.
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)
    print(f"[INFO] Reading VTU file: {vtu_path}")

    print("\n[AVAILABLE FIELDS]")
    print("  Point data:")
    if grid.point_data:
        for i, name in enumerate(grid.point_data.keys(), 1):
            arr = grid.point_data[name]
            print(f"    {i:2d}) {name:<30} shape={arr.shape}")
    else:
        print("    None")

    print("\n  Cell data:")
    if grid.cell_data:
        for i, name in enumerate(grid.cell_data.keys(), 1):
            arr = grid.cell_data[name]
            print(f"    {i:2d}) {name:<30} shape={arr.shape}")
    else:
        print("    None")

    grid = pv.read(vtu_path)
    xmin, xmax, ymin, ymax, zmin, zmax = grid.bounds
    print(f"\n[INFO] Grid bounds:")
    print(f"\tx ∈ [{xmin:.4e}, {xmax:.4e}]")
    print(f"\ty ∈ [{ymin:.4e}, {ymax:.4e}]")
    print(f"\tz ∈ [{zmin:.4e}, {zmax:.4e}]")


# --.. ..- .-.. .-.. --- extractors --.. ..- .-.. .-.. ---
def extract_VonMises(vtu_path, return_coords=True, prefer="cells"):
    """
    Extract Von Mises equivalent stress and coordinates from VTU.

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    return_coords : bool, optional
        If True, returns x, y, z arrays together with Von Mises stress.
    prefer : str, optional
        "points" or "cells" (default: "cells").

    Returns
    -------
    sigma_vm : np.ndarray
        Numpy array of Von Mises stress values.
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates of each data point or cell center.
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)

    loc_vm, field_vm = _detect_VonMises(grid, prefer)
    data, coords = _data_coords(grid, loc_vm, field_vm)
    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]

    if return_coords:
        return x, y, z, data
    else:
        return data


def extract_field(vtu_path, field_name, return_coords=True):
    """
    Extract a field (scalar or vector) and coordinates from a VTU file.

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    field_name : str
        Name of the field to extract (e.g. "temperature", "heat_flux").
    return_coords : bool, optional
        If True, returns x, y, z arrays together with the field.

    Returns
    -------
    field : np.ndarray
        Numpy array of field values (Nx1 for scalars, Nx3 for vectors).
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates of each point (or cell center if data is in cell_data).
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)

    loc_t, field_t = _detect_field(grid, field_name)
    data, coords = _data_coords(grid, loc_t, field_t)

    if return_coords:
        x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
        return x, y, z, data
    else:
        return data


def extract_temperature(vtu_path, return_coords=True):
    """
    Extract temperature field and coordinates from VTU.

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    return_coords : bool, optional
        If True, returns x, y, z arrays together with temperature.

    Returns
    -------
    temperature : np.ndarray
        Numpy array of temperature values.
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates of each data point or cell center.
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)

    loc_t, field_t = _detect_temp_field(grid)
    data, coords = _data_coords(grid, loc_t, field_t)

    if return_coords:
        x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
        return x, y, z, data
    else:
        return data


def extract_displacement(vtu_path, return_coords=True):
    """
    Extract displacement field and coordinates from VTU.

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    return_coords : bool, optional
        If True, returns x, y, z arrays together with displacement.

    Returns
    -------
    displacement : np.ndarray
        Numpy array of displacement values.
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates of each data point or cell center.
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)

    loc, field = _detect_displacement(grid)
    data, coords = _data_coords(grid, loc, field)

    if return_coords:
        x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
        return x, y, z, data
    else:
        return data


def extract_stress(vtu_path, component="xx", return_coords=True, prefer="cells"):
    """
    Extract stress tensor from VTU (by default σ_xx).

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    component : str, optional
        Stress tensor component to extract ('xx', 'yy', 'zz', 'xy', 'xz', 'yz').
    return_coords : bool, optional
        If True, returns x, y, z arrays together with stress component.
    prefer : str, optional
        "points" or "cells" (default: "points").

    Returns
    -------
    stress_comp : np.ndarray
        Array of the selected stress component.
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates corresponding to stress values.
    """
    if not os.path.exists(vtu_path):
        raise FileNotFoundError(f"VTU file not found: {vtu_path}")

    grid = pv.read(vtu_path)

    loc_s, field_name = _detect_sigma(grid, prefer=prefer)
    data, coords = _data_coords(grid, loc_s, field_name)

    data = np.asarray(data)
    if data.ndim == 2 and data.shape[1] == 9:
        stress_tensors = data.reshape(-1, 3, 3)
    else:
        raise ValueError(f"Unexpected stress data shape: {data.shape}")

    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
    comp_map = {"xx": (0, 0), "yy": (1, 1), "zz": (2, 2), "xy": (0, 1), "xz": (0, 2), "yz": (1, 2)}
    if component == "all":
        comps = {
            "xx": stress_tensors[:, 0, 0],
            "yy": stress_tensors[:, 1, 1],
            "zz": stress_tensors[:, 2, 2],
            "xy": stress_tensors[:, 0, 1],
            "xz": stress_tensors[:, 0, 2],
            "yz": stress_tensors[:, 1, 2],
        }
        return x, y, z, comps if return_coords else comps

    if component not in comp_map:
        raise ValueError(f"Invalid component '{component}'. Choose among {list(comp_map.keys())}.")

    i, j = comp_map[component]
    stress_comp = stress_tensors[:, i, j]

    return x, y, z, stress_comp if return_coords else stress_comp


def extract_strain(vtu_path, component="xx"):
    grid = pv.read(vtu_path)
    loc_e, field_name = _detect_field(grid, "Strain (cells)")
    data, coords = _data_coords(grid, loc_e, field_name)

    data = np.asarray(data)
    if data.ndim == 2 and data.shape[1] == 9:
        strain_tensors = data.reshape(-1, 3, 3)
    else:
        raise ValueError(f"Unexpected strain data shape: {data.shape}")

    comp_map = {"xx": (0, 0), "yy": (1, 1), "zz": (2, 2), "xy": (0, 1), "xz": (0, 2), "yz": (1, 2)}

    if component == "all":
        comps = {k: strain_tensors[:, i, j] for k, (i, j) in comp_map.items()}
        return coords[:, 0], coords[:, 1], coords[:, 2], comps

    i, j = comp_map[component]
    return coords[:, 0], coords[:, 1], coords[:, 2], strain_tensors[:, i, j]


def extract_principal_stresses(
    vtu_path,
    return_coords=True,
    prefer="points",
    average=None,
    n_bins=100,
    decimals=3,
    bandwidth=0.0005,
):
    """
    Extract principal stresses (σ₁, σ₂, σ₃) from a VTU file by diagonalizing
    the stress tensor at each point or cell, with optional radial averaging.

    Parameters
    ----------
    vtu_path : str
        Path to the .vtu file.
    return_coords : bool, optional
        If True, returns (x, y, z) coordinates.
    prefer : str, optional
        Prefer 'points' or 'cells' when both exist in VTU.
    average : str or None, optional
        Radial averaging method: 'bins', 'weighted', 'kernel', 'round', or None.
    n_bins : int, optional
        Number of bins for 'bins' or 'weighted' averaging.
    decimals : int, optional
        Round precision for 'round' averaging.
    bandwidth : float, optional
        Kernel bandwidth for 'kernel' averaging.

    Returns
    -------
    sigma1, sigma2, sigma3 : np.ndarray
        Arrays of the three principal stresses (ordered σ₁ ≥ σ₂ ≥ σ₃),
        optionally radially averaged.
    (x, y, z) : np.ndarray, np.ndarray, np.ndarray (optional)
        Coordinates of each point or cell center.
    """
    x, y, z, comps = extract_stress(vtu_path, component="all", return_coords=True, prefer=prefer)

    s_xx, s_yy, s_zz = comps["xx"], comps["yy"], comps["zz"]
    s_xy, s_xz, s_yz = comps["xy"], comps["xz"], comps["yz"]

    stress_tensors = np.stack(
        [
            np.stack([s_xx, s_xy, s_xz], axis=1),
            np.stack([s_xy, s_yy, s_yz], axis=1),
            np.stack([s_xz, s_yz, s_zz], axis=1),
        ],
        axis=1,
    )  # shape (N,3,3)

    eigvals = np.linalg.eigvalsh(stress_tensors)
    sigma1, sigma2, sigma3 = eigvals[:, 2], eigvals[:, 1], eigvals[:, 0]

    if average:
        from utils_plot import (
            radial_average_kernel,
            radial_average_round,
            radial_average_uniform_bins,
            radial_average_weighted,
        )

        print(f"[INFO] Applying radial averaging ({average}) on principal stresses...")

        if average == "bins":
            r_avg, sigma1 = radial_average_uniform_bins(x, y, z, sigma1, n_bins=n_bins)
            _, sigma2 = radial_average_uniform_bins(x, y, z, sigma2, n_bins=n_bins)
            _, sigma3 = radial_average_uniform_bins(x, y, z, sigma3, n_bins=n_bins)
        elif average == "weighted":
            r_avg, sigma1 = radial_average_weighted(x, y, z, sigma1, n_bins=n_bins)
            _, sigma2 = radial_average_weighted(x, y, z, sigma2, n_bins=n_bins)
            _, sigma3 = radial_average_weighted(x, y, z, sigma3, n_bins=n_bins)
        elif average == "kernel":
            r_avg, sigma1 = radial_average_kernel(x, y, z, sigma1, bandwidth=bandwidth)
            _, sigma2 = radial_average_kernel(x, y, z, sigma2, bandwidth=bandwidth)
            _, sigma3 = radial_average_kernel(x, y, z, sigma3, bandwidth=bandwidth)
        elif average == "round":
            r_avg, sigma1 = radial_average_round(x, y, z, "sigma1", sigma1, decimals=decimals)
            _, sigma2 = radial_average_round(x, y, z, "sigma2", sigma2, decimals=decimals)
            _, sigma3 = radial_average_round(x, y, z, "sigma3", sigma3, decimals=decimals)
        else:
            raise ValueError(f"Unknown averaging method '{average}'.")

        if return_coords:
            return r_avg, np.zeros_like(r_avg), np.zeros_like(r_avg), sigma1, sigma2, sigma3
        else:
            return sigma1, sigma2, sigma3

    if return_coords:
        return x, y, z, sigma1, sigma2, sigma3
    else:
        return sigma1, sigma2, sigma3


def extract_spherical_stresses(
    vtu_path,
    return_coords=True,
    prefer="points",
    average=None,
    n_bins=100,
    decimals=3,
    bandwidth=0.0005,
):
    """
    Extract and convert the stress tensor (σ_xx, σ_yy, σ_zz, σ_xy, σ_xz, σ_yz)
    in spherical coordinates σ_rr, σ_tt, σ_pp (θθ, φφ).

    Parameters
    ----------
    vtu_path : str
        VTU path
    return_coords : bool, (optional)
        If True, returns (r, θ, φ). Default True.
    prefer : str, (optional)
        "points" o "cells" for VTU data.
    average : str o None
        Method for the radial average: "bins", "weighted", "kernel", "round", None.
    n_bins : int
        Number of radial bins, if average="bins" or "weighted".
    decimals : int
        Number of decimals if average="round".
    bandwidth : float
        Band for smoothing kernel.

    Returns
    -------
    If return_coords=True:
        r, theta, phi, sigma_rr, sigma_tt, sigma_pp
    Otherwise:
        sigma_rr, sigma_tt, sigma_pp
    """
    import numpy as np
    from utils_extract_vtu import extract_stress

    x, y, z, comps = extract_stress(vtu_path, component="all", return_coords=True, prefer=prefer)

    s_xx, s_yy, s_zz = comps["xx"], comps["yy"], comps["zz"]
    s_xy, s_xz, s_yz = comps["xy"], comps["xz"], comps["yz"]

    # --. Spherical coordinates --..
    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(np.divide(z, r, out=np.zeros_like(z), where=r > 0))  # [ 0, π]
    phi = np.arctan2(y, x)  # [-π, π]

    cth, sth = np.cos(theta), np.sin(theta)
    cph, sph = np.cos(phi), np.sin(phi)

    sigma_rr = (
        s_xx * sth**2 * cph**2
        + s_yy * sth**2 * sph**2
        + s_zz * cth**2
        + 2 * s_xy * sth**2 * sph * cph
        + 2 * s_xz * sth * cth * cph
        + 2 * s_yz * sth * cth * sph
    )

    sigma_tt = (
        s_xx * (cth * cph) ** 2
        + s_yy * (cth * sph) ** 2
        + s_zz * sth**2
        + 2 * s_xy * cth**2 * sph * cph
        - 2 * s_xz * sth * cth * cph
        - 2 * s_yz * sth * cth * sph
    )

    sigma_pp = s_xx * sph**2 + s_yy * cph**2 - 2 * s_xy * sph * cph

    # --. Averaging (Optional) --..
    if average:
        from utils_plot import (
            radial_average_kernel,
            radial_average_round,
            radial_average_uniform_bins,
            radial_average_weighted,
        )

        print(f"[INFO] Applying radial averaging ({average}) on spherical stresses...")

        if average == "bins":
            r_avg, sigma_rr = radial_average_uniform_bins(x, y, z, sigma_rr, n_bins=n_bins)
            _, sigma_tt = radial_average_uniform_bins(x, y, z, sigma_tt, n_bins=n_bins)
            _, sigma_pp = radial_average_uniform_bins(x, y, z, sigma_pp, n_bins=n_bins)
        elif average == "weighted":
            r_avg, sigma_rr = radial_average_weighted(x, y, z, sigma_rr, n_bins=n_bins)
            _, sigma_tt = radial_average_weighted(x, y, z, sigma_tt, n_bins=n_bins)
            _, sigma_pp = radial_average_weighted(x, y, z, sigma_pp, n_bins=n_bins)
        elif average == "kernel":
            r_avg, sigma_rr = radial_average_kernel(x, y, z, sigma_rr, bandwidth=bandwidth)
            _, sigma_tt = radial_average_kernel(x, y, z, sigma_tt, bandwidth=bandwidth)
            _, sigma_pp = radial_average_kernel(x, y, z, sigma_pp, bandwidth=bandwidth)
        elif average == "round":
            r_avg, sigma_rr = radial_average_round(x, y, z, "sigma_rr", sigma_rr, decimals=decimals)
            _, sigma_tt = radial_average_round(x, y, z, "sigma_tt", sigma_tt, decimals=decimals)
            _, sigma_pp = radial_average_round(x, y, z, "sigma_pp", sigma_pp, decimals=decimals)
        else:
            raise ValueError(f"Unknown averaging method '{average}'.")

        if return_coords:
            return r_avg, np.zeros_like(r_avg), np.zeros_like(r_avg), sigma_rr, sigma_tt, sigma_pp
        else:
            return sigma_rr, sigma_tt, sigma_pp

    # --.. Output not averaged --..
    if return_coords:
        return r, theta, phi, sigma_rr, sigma_tt, sigma_pp
    else:
        return sigma_rr, sigma_tt, sigma_pp


def extract_cylindrical_stresses(
    filename="output/fields.vtu",
    z_fixed=0.0,
    tol=1e-3,
    case_dir=".",
    stress_field_hint="Stress",
    data_source="auto",
    average=True,
    decimals=6,
    save_results=False,
):
    """
    Extract a .csv σ_rr, σ_θθ, σ_zz at a fixed z from a .vtu file (cell or point data).

    Parameters
    ----------
    filename : str
        Path to the VTU file.
    z_fixed : float
        Z coordinate of the slice (m).
    tol : float
        Tolerance for slice selection.
    stress_field_hint : str
        Keyword to detect stress field (default: 'Stress').
    data_source : str
        'cell', 'point', or 'auto' (default).
    """

    # --- Load file ---
    if not os.path.exists(filename):
        raise FileNotFoundError(f"[ERROR] File not found: {filename}")
    grid = pv.read(filename)

    # --- Detect stress field ---
    stress_field_name = None
    if data_source in ("auto", "cell"):
        for key in grid.cell_data.keys():
            if stress_field_hint.lower() in key.lower():
                stress_field_name = key
                data_source = "cell"
                break

    if stress_field_name is None and data_source in ("auto", "point"):
        for key in grid.point_data.keys():
            if stress_field_hint.lower() in key.lower():
                stress_field_name = key
                data_source = "point"
                break

    if stress_field_name is None:
        raise KeyError(f"No stress field found (searched '{stress_field_hint}') in {filename}")

    print(f"[INFO] Using stress field '{stress_field_name}' from {data_source}_data")

    if data_source == "cell":
        stress = grid.cell_data[stress_field_name].reshape((-1, 3, 3))
        coords = grid.cell_centers().points
    elif data_source == "point":
        stress = grid.point_data[stress_field_name].reshape((-1, 3, 3))
        coords = grid.points

    # --- Select slice ---
    mask = np.abs(coords[:, 2] - z_fixed) < tol
    if np.sum(mask) == 0:
        raise ValueError(f"No data found at z = {z_fixed:.4e} ± {tol:.1e}")
    x, y = coords[mask, 0], coords[mask, 1]
    sxx, syy, szz, sxy = (
        stress[mask, 0, 0],
        stress[mask, 1, 1],
        stress[mask, 2, 2],
        stress[mask, 0, 1],
    )

    # --- Convert to cylindrical ---
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    c, s = np.cos(theta), np.sin(theta)
    sigma_rr = sxx * c**2 + syy * s**2 + 2 * sxy * s * c
    sigma_tt = sxx * s**2 + syy * c**2 - 2 * sxy * s * c
    sigma_zz = szz

    import pandas as pd

    df = pd.DataFrame(
        {"r": r, "sigma_rr": sigma_rr, "sigma_tt": sigma_tt, "sigma_zz": sigma_zz}
    ).sort_values("r")

    # --- Average by radius (optional) ---
    if average:
        df["r"] = df["r"].round(decimals)
        df = df.groupby("r")[["sigma_rr", "sigma_tt", "sigma_zz"]].mean().reset_index()

    # --- Save results ---
    if save_results:
        out_dir = os.path.join(case_dir, "output")
        os.makedirs(out_dir, exist_ok=True)
        csv_path = os.path.join(out_dir, f"stress_profile_z{z_fixed:.4e}.csv")
        df.to_csv(csv_path, index=False)
        print(f"[DATA] Stress profile saved → {csv_path}")

    return (
        df["r"].to_numpy(),
        df["sigma_rr"].to_numpy(),
        df["sigma_tt"].to_numpy(),
        df["sigma_zz"].to_numpy(),
    )


def save_csv_principal_stress(
    filename="output/fields.vtu",
    z_fixed=0.0,
    tol=1e-3,
    case_dir=".",
    stress_field_hint="Stress",
    data_source="auto",
    average=True,
    decimals=6,
):
    """
    Extract a .csv σ_1, σ_2, σ_3 at a fixed z from a .vtu file (cell or point data).

    Parameters
    ----------
    filename : str
        Path to the VTU file.
    z_fixed : float
        Z coordinate of the slice (m).
    tol : float
        Tolerance for slice selection.
    stress_field_hint : str
        Keyword to detect stress field (default: 'Stress').
    data_source : str
        'cell', 'point', or 'auto' (default).
    """

    # --- Load file ---
    if not os.path.exists(filename):
        raise FileNotFoundError(f"[ERROR] File not found: {filename}")
    grid = pv.read(filename)

    # --- Detect stress field ---
    stress_field_name = None
    if data_source in ("auto", "cell"):
        for key in grid.cell_data.keys():
            if stress_field_hint.lower() in key.lower():
                stress_field_name = key
                data_source = "cell"
                break

    if stress_field_name is None and data_source in ("auto", "point"):
        for key in grid.point_data.keys():
            if stress_field_hint.lower() in key.lower():
                stress_field_name = key
                data_source = "point"
                break

    if stress_field_name is None:
        raise KeyError(f"No stress field found (searched '{stress_field_hint}') in {filename}")

    print(f"[INFO] Using stress field '{stress_field_name}' from {data_source}_data")

    if data_source == "cell":
        stress = grid.cell_data[stress_field_name].reshape((-1, 3, 3))
        coords = grid.cell_centers().points
    elif data_source == "point":
        stress = grid.point_data[stress_field_name].reshape((-1, 3, 3))
        coords = grid.points

    # --- Select slice at z = z_fixed ---
    mask = np.abs(coords[:, 2] - z_fixed) < tol
    if np.sum(mask) == 0:
        raise ValueError(f"No data found at z = {z_fixed:.4e} ± {tol:.1e}")

    x, y = coords[mask, 0], coords[mask, 1]
    r = np.sqrt(x**2 + y**2)

    # --- Principal stresses computation ---
    stresses = stress[mask]
    eigvals = np.linalg.eigvalsh(stresses)
    sigma1, sigma2, sigma3 = eigvals[:, 2], eigvals[:, 1], eigvals[:, 0]

    import pandas as pd

    df = pd.DataFrame({"r": r, "sigma1": sigma1, "sigma2": sigma2, "sigma3": sigma3}).sort_values(
        "r"
    )

    # --- Average by radius (optional) ---
    if average:
        df["r"] = df["r"].round(decimals)
        df = df.groupby("r")[["sigma1", "sigma2", "sigma3"]].mean().reset_index()

    # --- Save results ---
    out_dir = os.path.join(case_dir, "output")
    os.makedirs(out_dir, exist_ok=True)
    csv_path = os.path.join(out_dir, f"stress_profile_z{z_fixed:.4e}.csv")
    df.to_csv(csv_path, index=False)
    print(f"[DATA] Stress profile saved → {csv_path}")

    return {
        "r": df["r"].to_numpy(),
        "sigma1": df["sigma1"].to_numpy(),
        "sigma2": df["sigma2"].to_numpy(),
        "sigma3": df["sigma3"].to_numpy(),
    }


def average_section(x, y, z, field, y0, z0, tol=1e-3, decimals=5, label="field"):
    """Extract and average field along x at fixed y,z plane."""
    mask = (np.abs(y - y0) < tol) & (np.abs(z - z0) < tol)
    if not np.any(mask):
        raise RuntimeError(f"[ERROR] No points found for {label} (tol={tol})")
    df = (
        pd.DataFrame({"x": x[mask].round(decimals), label: field[mask]})
        .groupby("x", as_index=False)
        .mean()
    )
    return df["x"].to_numpy(), df[label].to_numpy()


def average_section_radial(x, y, z, field, z_target, tol=1e-3, decimals=5):
    """Average a scalar field over constant-z plane along radius r = sqrt(x² + y²)."""
    r = np.sqrt(x**2 + y**2)
    mask = np.abs(z - z_target) < tol
    if not np.any(mask):
        raise RuntimeError(f"No points found near z={z_target:.3f} ± {tol:.1e}")
    df = pd.DataFrame({"r": r[mask].round(decimals), "f": field[mask]})
    df = df.groupby("r", as_index=False).mean()
    return df["r"].to_numpy(), df["f"].to_numpy()
